Verziókezelés
A projekt fejlesztése során kiemelt figyelmet fordítottunk a verziókezelésre, hogy biztosítsuk a kódok nyomon követhetőségét, a csapatmunka hatékonyságát és a folyamatos integráció lehetőségét. A verziókezelés célja, hogy lehetővé tegye a kódok közötti különbségek könnyű összehasonlítását, a fejlesztések egyes szakaszaiba való visszaállást, valamint az új funkciók és hibajavítások folyamatos implementálását.
A verziókezelés alapvetően a Git segítségével történt, amely egy elosztott verziókezelő rendszer. A Git előnye, hogy lehetővé teszi a fejlesztők számára, hogy a helyi gépükön dolgozzanak, majd később a központi tárolóra (repositoryra) töltsék fel a módosításokat, ahol a többi csapattag is hozzáférhet és integrálhatja a változtatásokat.
A GitHub platformot választottuk a projekt tárolására, mivel ez lehetőséget biztosít a kód távoli tárolására, a csapaton belüli együttműködésre és a közvetlen hibajavításokra is. A GitHub az online tárolás mellett egy sor hasznos funkciót is kínál, például issue tracking (problémakövetés), pull request (kódellenőrzés és -összevonás), valamint branching (ágak kezelése) lehetőségeket.
A verziókezelő rendszer használata a csapatmunka hatékonyságát is jelentősen növelte. A GitHub lehetőséget biztosított a párhuzamos munkavégzésre, így a csapattagok egy időben dolgozhattak különböző funkciók fejlesztésén anélkül, hogy egymás módosításait felülírták volna. Emellett a hibák azonosítása és javítása is gördülékenyebbé vált; a commit-ok, a pull request-ek és az issue-k rendszere lehetővé tette a felmerülő problémák pontos nyomon követését és azok gyors megoldását.
A fejlesztési folyamat így nemcsak gyorsabb, hanem biztonságosabb is lett. Az ágak (branch-ek) és verziók tudatos kezelésével biztosítottuk a munkafolyamat teljes átláthatóságát, miközben a hibák kockázatát a minimálisra csökkentettük. Ez a strukturált környezet minden szakaszban hozzáférhető és ellenőrizhető keretet nyújtott a közös fejlesztéshez.
Tesztelés
A szoftvertesztelés jelentősége
A szoftverfejlesztési életciklus egyik legkritikusabb szakasza a tesztelés, amely biztosítja, hogy az alkalmazás megfeleljen az előzetesen lefektetett funkcionális követelményeknek, és megbízhatóan működjön a végfelhasználók számára. Egy mezőgazdasági hozamszámító alkalmazás esetében a pontosság alapvető elvárás, hiszen a gazdák ezen adatok alapján hozzák meg pénzügyi döntéseiket. A tesztelés célja nem csupán a hibák felderítése, hanem a kód regressziótűrésének biztosítása is: garantálja, hogy egy új funkció bevezetése vagy egy módosítás ne rontsa el a már meglévő, jól működő rendszerelemeket.
A Jest keretrendszer bemutatása
A backend szolgáltatások ellenőrzésére a Jest keretrendszert választottuk, amely napjaink egyik legnépszerűbb JavaScript-alapú tesztelési eszköze. A Jest mellett szólt annak rendkívüli sebessége, egyszerű konfigurálhatósága, valamint a beépített „mocking” funkciói, amelyek lehetővé teszik a külső függőségek – például adatbázisok vagy harmadik féltől származó könyvtárak – szimulálását. A tesztek futtatása során a Supertest könyvtárat is igénybe vettük, amely segítségével HTTP-kéréseket tudtunk szimulálni az API végpontjaink felé, így anélkül kaptunk választ a végpontok működéséről, hogy a teljes szerverkörnyezetet manuálisan el kellett volna indítanunk.
Unit tesztek megvalósítása a gyakorlatban
A tesztelési folyamat során egységteszteket (unit tests) írtunk a backend kulcsfontosságú végpontjaira. Annak érdekében, hogy tesztjeink izoláltak legyenek és ne módosítsák az éles adatbázist, ún. mocking technológiát alkalmaztunk. Szimuláltuk a mysql2 adatbázis-meghajtó és a bcrypt titkosító könyvtár működését, így a tesztek futása nem függött külső szolgáltatások állapotától.
A gyakorlati megvalósítás során a tesztesetek a rendszer kritikus funkcióit fedték le, különös tekintettel az adatbázis-műveletek integritására és a végpontok válaszainak helyességére. Az adattörlési folyamatok validálása érdekében vizsgáltuk a tervezet törléséért felelős végpont (DELETE /api/terv/:id) működését. A tesztelés során szimuláltuk a sikeres adatbázis-műveletet, majd ellenőriztük, hogy a rendszer a specifikációnak megfelelő SQL lekérdezést futtatja-e le a helyes paraméterezéssel. Ezen felül igazoltuk, hogy a kliensoldal minden esetben megkapja az elvárt 200-as státuszkódot és a művelet sikerességét visszaigazoló üzenetet.
Az adatlekérdezési funkciók validálása keretében külön tesztesetben vizsgáltuk a növények listázását végző szolgáltatást (GET /api/noveny). Az ellenőrzés fókuszában az állt, hogy az adatbázisból származó rekordok – úgymint az egyedi azonosítók, megnevezések és a kapcsolódó médiafájlok elérési útjai – strukturálisan megfelelő JSON formátumban érkeznek-e meg a felhasználói felületre. Hasonló módon került sor az összetettebb, paraméterezett lekérdezések tesztelésére is, például egy adott földterülethez tartozó kiadások számának lekérésekor (GET /api/kiadasok_szam/:id). Ez a vizsgálat megerősítette, hogy a backend üzleti logikája képes a bemeneti paraméterek pontos kezelésére és az aggregált adatok torzításmentes továbbítására.
A tesztelési környezet stabilitásának és a mérések objektivitásának megőrzése érdekében minden teszteset futtatása előtt alaphelyzetbe állítottuk a szimulált objektumokat a jest.clearAllMocks() metódus segítségével. Ez a lépés garantálta a tesztek közötti teljes függetlenséget, megakadályozva az esetleges mellékhatások átöröklődését, és biztosítva az eredmények bármikori megismételhetőségét.
Frontend tesztelés és a Jasmine keretrendszer
Az alkalmazás felhasználói felületének megbízhatóságát és a kliensoldali logika helyességét a Jasmine tesztelési keretrendszer segítségével biztosítottuk. Mivel a frontend felelős a mezőgazdasági adatok megjelenítéséért és a felhasználói interakciók kezeléséért, elengedhetetlen volt egy olyan eszköz használata, amely átlátható és jól strukturált módon teszi lehetővé a viselkedésalapú fejlesztést (Behavior-Driven Development). A Jasmine választását indokolta, hogy egy függőségektől mentes, tiszta szintaxisú keretrendszer, amely kiválóan alkalmas a böngészőben futó folyamatok szimulálására.
A frontend tesztelése során az egységtesztek (unit tests) megírásakor arra törekedtünk, hogy izoláljuk a komponenseket és a segédfüggvényeket. Ez magában foglalta a felhasználói bevitelek validálását, a számítási algoritmusok pontosságának ellenőrzését – ami a hozambecslő funkciónál kiemelt prioritást élvezett –, valamint a navigációs logika tesztelését. A Jasmine beépített spy funkcióit (például spyOn) alkalmaztuk a külső API-hívások és aszinkron folyamatok megfigyelésére, így biztosítva, hogy a tesztek ne a tényleges hálózati forgalomtól, hanem kizárólag a komponensek belső állapotától függjenek.
A tesztelési folyamat során kialakítottunk egy automatizált munkafolyamatot, amely lehetővé tette a tesztesetek gyors lefuttatását minden módosítás után. Ez a megközelítés minimálisra csökkentette a felületi hibák (UI bugs) megjelenésének esélyét, és garantálta, hogy a webes és mobilfelületen is egységes, hibamentes élményben részesüljenek a gazdálkodók. A sikeresen lefutott Jasmine tesztek megerősítették, hogy az alkalmazás frontend rétege stabilan kezeli a dinamikus adatokat és robusztusan reagál a váratlan felhasználói interakciókra is.

